#+TITLE: Readme

* Tabella dei contenuti :TOC:
- [[#descrizione-del-progetto][Descrizione del progetto]]
  - [[#home-page][Home page]]
  - [[#popolazione-del-database][Popolazione del database]]
  - [[#pagine-vtuber][Pagine VTuber]]
- [[#setup][Setup]]
  - [[#configurazione-ed-installazione-server][Configurazione ed installazione server]]
  - [[#esecuzione-server][Esecuzione server]]
- [[#realizzazione][Realizzazione]]
  - [[#entry-point---indexphp][Entry point - index.php]]
  - [[#core][Core]]

* Descrizione del progetto
Su [questo-sito] è possibile registrare un account con cui si può tenere traccia di:
- Anime visti
- Manga letti
- Visual novel giocate
- Light novel lette

Inoltre è possibile realizzare una lista di VTuber preferite, seguire le loro live e ricevere notifiche via e-mail quando sono in live.

** Home page
Nella home page è possibile vedere una lista delle ultime uscite divise per categoria [anime, manga, LN, VN] e per genere [azione, horror, sportivo, sci-fi, ...].

** Popolazione del database
Sarà compito dell'utente registrato creare un nuovo record per aggiungere una serie di una specifica categoria al database.
Una volta creato il record, chiunque altro sia registrato è in grado di apportare modifiche.
Questo processo lo effettua attraverso una pagina di registrazione, dove l'utente dovrà inserire:

*** ... per gli anime
- Titolo
- Tipo di anime [film, serie TV, speciale]
- Stato pubblicazione
    + Numero episodi se lo stato è *concluso*
- Data di inizio/fine pubblicazione
- Trama
- Generi
- Immagine di copertina

*** ... per manga e light novel
- Titolo
- Stato pubblicazione
  + Numero di capitoli e volumi se lo stato è *concluso*
- Data di inizio/fine pubblicazione
- Trama
- Generi
- Immagine di copertina

*** ... per visual novel
- Titolo
- Link del seller
- Trama
- Generi
- Immagine di copertina

** Pagine VTuber
Speciale pagina da cui poter partecipare alla stream della particolare VTuber direttamente, senza bisogno di recarsi sulla pagina YouTube/Twitch dell'idol in questione.
Se l'idol non è attualmente live viene mostrata una pagina che notifica l'utente che lo stream è offline.

* Setup
** Configurazione ed installazione server
*** Server web - Nginx
Ho deciso di utilizzare Nginx come web server per le performance nettamente migliori e leggerezza in confronto ad altri web server.
L'installazione viene effettuata tramite un docker container e la seguente container image:
#+begin_src dockerfile :tangle dockerfiles/web/Dockerfile
FROM php:8.1.4-fpm-alpine3.14
WORKDIR /var/www/html

RUN apk update && apk add --no-cache \
    php8 \
    php8-fpm \
    php8-mysqli \
    nginx

RUN docker-php-ext-install pdo pdo_mysql mysqli
RUN docker-php-ext-enable pdo_mysql

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
RUN php-fpm &

COPY nginx.conf /etc/nginx/nginx.conf
CMD php-fpm -D && nginx -g "daemon off;"
#+end_src

Nginx utilizza il seguente file di configurazione:
#+begin_src conf :tangle dockerfiles/web/nginx.conf
user nginx;
worker_processes 4;

error_log /var/log/nginx/error.log warn;

events {
    worker_connections 1024;
}

http {
        server {
               listen 80 default_server;
               listen [::]:80 default_server;

               root /var/www/html/pub;
               index index.php index.html index.htm index.nginx-debian.html;
               server_name _;

               location / {
                        try_files $uri $uri/ =404;
                }

                location ~ \.php$ {
                        fastcgi_pass      127.0.0.1:9000;
                        fastcgi_index     index.php;
                        include           fastcgi.conf;
                }
        }
}
#+end_src

*** Server database - MariaDB
L'installazione del database server mariadb viene anch'essa eseguita tramite un docker container e la container image disponibile su [[https://hub.docker.com/_/mariadb][hub.docker]] per cui non ha bisogno di alcuna configurazione.

** Esecuzione server
Eseguire i seguenti comandi a riga di comando per creare e avviare i container:
#+begin_src sh
docker build -t nomeContainerImage dockerfiles/web
docker run -dp 80:80 -v "$PWD/www":/var/www/html nomeContainerImage

docker run -dp 3306:3306 -v "$PWD/DBfiles":/var/lib/mysql -e MARIADB_ROOT_PASSWORD=root --name animedb mariadb:latest --port 3306
#+end_src

* Realizzazione
La web app è strutturata seguendo il *Model View Controller* framework.
Per gestire le dipendenze e namespaces di PHP viene utilizzato *composer*.

** Entry point - index.php
La home page, si occupa di inizializzare l'applicazione ed impostare le route con annessa funzione di callback o *View*.

#+begin_src php :tangle www/pub/index.php
<?php
require_once __DIR__."/../vendor/autoload.php";
use app\core\Application;

$app = new Application();

$app->router->get("/", function() {
    return "Hello World!";
});
$app->router->get("/contact", function() {
    return "Contact me!";
});

$app->run();
?>
#+end_src

** Core
*** Main application class
La classe principale, si occupa di instanziare il Router e la Request helper class.

#+begin_src php :tangle www/core/Application.php
<?php
namespace app\core;

class Application {
    public Router $router;
    public Request $req;

    public function __construct() {
        $this->req = new Request();
        $this->router = new Router($this->req);
    }

    public function run() {
        $this->router->resolve();
    }
}
?>
#+end_src

*** Router class
Una delle classi principali è il Router, gestisce l'array associativo "$routes" e la risoluzione delle varie request effettuate.

L'array associativo "$routes" è diviso in 2 grandi sottogruppi:
- sottogruppo "get"
- sottogruppo "post"

Ogni sottogruppo a sua volta è formato da 2 campi: "path" => "method".

#+begin_example
{
    ["get"] => {
        ["/"] => func(),
        ["/test"] => func(),
    },

    ["post"] => {
        ["/"] => func(),
        ["/test"] => func(),
    }
}
#+end_example

Metodi:
- "get()": imposta la route con metodo get
- "post()": imposta la route con metodo post
- "resolve()": utilizzando la Request helper class ricava quale funzione di callback chiamare sullo specifico path e metodo richiesto

#+begin_src php :tangle www/core/Router.php
<?php
namespace app\core;

class Router
{
    public Request $req;
    private array $routes = [];

    public function __construct(Request $req)
    {
        $this->req = $req;
    }

    public function get($path, $callback)
    {
        $this->routes["get"][$path] = $callback;
    }

    public function post($path, $callback)
    {
        $this->routes["post"][$path] = $callback;
    }


    public function resolve()
    {
        $path = $this->req->getPath();
        $method = $this->req->getMethod();
        $callback = $this->routes[$method][$path] ?? false;

        if ($callback) {
            echo call_user_func($callback);
        } else {
            echo "Not found!";
        }
    }
}
?>
#+end_src

*** Request class
Una classe helper, analizza le requests e restituisce l'informazione necessaria al richiedente.

Metodi:
- "getPath()": restituisce il path richiesto, se viene passata una query string insieme al path essa non viene restituita. (Utile a Router resolve())
- "getMethod()": restituisce il metodo utilizzato nella request in minuscolo. (Utile a Router resolve())

#+begin_src php :tangle www/core/Request.php
<?php
namespace app\core;

class Request {
    public function getPath() {
        $path = $_SERVER["REQUEST_URI"] ?? "/";
        $position = strpos($path, "?");

        if (!$position) {
            return $path;
        }
        return substr($path, 0, $position);
    }

    public function getMethod() {
        return strtolower($_SERVER["REQUEST_METHOD"]);
    }

    public function getBody() {
        # TODO
    }
}
?>
#+end_src
