#+TITLE: Readme

* Tabella dei contenuti :TOC:
- [[#descrizione-del-progetto][Descrizione del progetto]]
  - [[#home-page][Home page]]
  - [[#popolazione-del-database][Popolazione del database]]
  - [[#pagine-vtuber][Pagine VTuber]]
- [[#setup][Setup]]
  - [[#configurazione-ed-installazione-server][Configurazione ed installazione server]]
  - [[#esecuzione-server][Esecuzione server]]
- [[#realizzazione][Realizzazione]]
  - [[#entry-point---indexphp][Entry point - index.php]]
  - [[#core][Core]]
  - [[#migrations][Migrations]]
  - [[#models][Models]]
  - [[#controllers][Controllers]]

* Descrizione del progetto
Su [questo-sito] è possibile registrare un account con cui si può tenere traccia di:
- Anime visti
- Manga letti
- Visual novel giocate
- Light novel lette

Inoltre è possibile realizzare una lista di VTuber preferite, seguire le loro live e ricevere notifiche via e-mail quando sono in live.

** Home page
Nella home page è possibile vedere una lista delle ultime uscite divise per categoria [anime, manga, LN, VN] e per genere [azione, horror, sportivo, sci-fi, ...].

** Popolazione del database
Sarà compito dell'utente registrato creare un nuovo record per aggiungere una serie di una specifica categoria al database.
Una volta creato il record, chiunque altro sia registrato è in grado di apportare modifiche.
Questo processo lo effettua attraverso una pagina di registrazione, dove l'utente dovrà inserire:

*** ... per gli anime
- Titolo
- Tipo di anime [film, serie TV, speciale]
- Stato pubblicazione
    + Numero episodi se lo stato è *concluso*
- Data di inizio/fine pubblicazione
- Trama
- Generi
- Immagine di copertina

*** ... per manga e light novel
- Titolo
- Stato pubblicazione
  + Numero di capitoli e volumi se lo stato è *concluso*
- Data di inizio/fine pubblicazione
- Trama
- Generi
- Immagine di copertina

*** ... per visual novel
- Titolo
- Link del seller
- Trama
- Generi
- Immagine di copertina

** Pagine VTuber
Speciale pagina da cui poter partecipare alla stream della particolare VTuber direttamente, senza bisogno di recarsi sulla pagina YouTube/Twitch dell'idol in questione.
Se l'idol non è attualmente live viene mostrata una pagina che notifica l'utente che lo stream è offline.

* Setup
** Configurazione ed installazione server
*** Server web - Nginx
Ho deciso di utilizzare Nginx come web server per le performance nettamente migliori e leggerezza in confronto ad altri web server.

L'installazione viene effettuata tramite un docker container e la seguente [[./dockerfiles/web/Dockerfile][container image]].
Nginx utilizza il seguente [[./dockerfiles/web/nginx.conf][file di configurazione]].

*** Server database - MariaDB
L'installazione del database server mariadb viene anch'essa eseguita tramite un docker container e la container image disponibile su [[https://hub.docker.com/_/mariadb][hub.docker]] per cui non ha bisogno di alcuna configurazione.

** Esecuzione server
Eseguire i seguenti comandi a riga di comando per creare e avviare i container:
#+begin_src sh
docker build -t nomeContainerImage dockerfiles/web
docker run -dp 80:80 -v "$PWD/www":/var/www/html nomeContainerImage

docker run -dp 3306:3306 -v "$PWD/DBfiles":/var/lib/mysql -e MARIADB_ROOT_PASSWORD=root --name animedb mariadb:latest --port 3306
#+end_src

* Realizzazione
La web app è strutturata seguendo il *Model View Controller* framework.
Per gestire le dipendenze e namespaces di PHP viene utilizzato *composer*.

** Entry point - index.php
La home page, si occupa di inizializzare l'applicazione ed impostare le route con annesso array [Controller, metodo].

#+begin_src php
$app = new Application(dirname(__DIR__));
$app->router->get("/", [SiteController::class, "home"]);
#+end_src

** Core
*** Main application class
La classe principale, si occupa di istanziare:
- la Router class
- la Request helper class
- la Response helper class

Rappresenta il fulcro della web app.
Rende possibile l'accesso a tutte le classi da essa istaziate tramite la viariabile statica "$app".

Gestisce tutti i controller tramite "BaseController".

*** Router class
Una delle classi principali è il Router, gestisce l'array associativo "$routes" e la risoluzione delle varie request effettuate.

L'array associativo "$routes" è diviso in 2 grandi sottogruppi:
- sottogruppo "get"
- sottogruppo "post"
#+begin_src php
public function get($path, $callback) {
    $this->routes["get"][$path] = $callback;
}

public function post($path, $callback) {
    $this->routes["post"][$path] = $callback;
}
#+end_src

Ogni sottogruppo a sua volta è formato da 2 campi: "path" => "method".
#+begin_example
{
    ["get"] => {
        ["/"] => func(),
        ["/test"] => func(),
    },

    ["post"] => {
        ["/"] => func(),
        ["/test"] => func(),
    }
}
#+end_example

Metodi:
- "get()": imposta la route con metodo get
- "post()": imposta la route con metodo post
- "resolve()": utilizzando la Request helper class ricava quale funzione di callback chiamare sullo specifico path e metodo richiesto
- "renderView()": unisce la view al layout del controller che la gestisce per poi venire mostrata all'utente finale come un'unica pagina:
  + "loadLayoutContent()": restituisce il contenuto del layout selezionato dal controller della specifica view
  + "loadViewContent()": restituisce il contenuto della specifica view

Per leggere il contenuto della view e del layout si utilizza la funzione "ob_start()" che attiva l'output buffering, invece di inviare l'output all'utente richiedente esso viene salvato in un buffer interno.
I dati salvati nel buffer possono venire recuperati tramite la funzione "ob_get_clean()" che a sua volta esegue "ob_get_contents()", per convertire i dati contenuti nel buffer in string, e "ob_end_clean()" per cancellare il buffer.
#+begin_src php
# loadViewContent() snippet
ob_start();
include_once Application::$ROOT_DIR."/views/$view.php";
return ob_get_clean();
#+end_src

Una volta prelevati i contenuti del layout e della view, si effettua una semplice str_replace per ottenere la view finale da poter mostrare all'utente.
#+begin_src php
# renderView() snippet
$layoutContent = $this->loadLayoutContent();
$viewContent = $this->loadViewContent($view, $params);

return str_replace("{{content}}", $viewContent, $layoutContent);
#+end_src

*** Request class
Una classe helper, analizza le requests e restituisce l'informazione necessaria al richiedente.

Metodi:
- "getPath()": restituisce il path richiesto, se viene passata una query string insieme al path essa non viene restituita. (Utile a Router resolve())
- "getMethod()": restituisce il metodo utilizzato nella request in minuscolo. (Utile a Router resolve())
- "getBody()": restituisce i valori inseriti nella richiesta, sia essa una GET o una POST.

*** Base model class
Classe model di base.
Tutti i model si basano su questa classe, facilmente permettendo:
- lettura dei dati tramite il metodo "loadData($data)"
- impostazione di regole tramite il metodo astratto "rules()" e le costanti "RULE_*"
- verifica della correttezza dei dati inseriti dall'utente tramite il metodo "validate()"
- notificazione della presenza di errori all'utente tramite i metodi:
  + "addError()"
  + "errorMessage()"

La verifica della validità di un dato viene effettuata attraverso l'iterazione dell'array associtivo restituito dal metodo astratto "rules()".
#+begin_example
[
    "attributo0" => [self::RULE_REQUIRED],
    "attributo1" => [self::RULE_REQUIRED, [ self::RULE_MIN, "min" => 20 ], [ self::RULE_MAX, "max" => 100 ]],
]
#+end_example

Per ogni "attributo => regole" e per ogni regola (un attributo può avere più regole) verifica quale controllo eseguire ed aggiunge un messaggio di errore in caso di fallimento del controllo.
#+begin_src php
# BaseModel::validate() snippet
if ($ruleName == self::RULE_REQUIRED && !$value) {
    $this->addError($attribute, self::RULE_REQUIRED);
}
if ($ruleName == self::RULE_EMAIL && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
    $this->addError($attribute, self::RULE_EMAIL);
}
if ($ruleName == self::RULE_MIN && strlen($value) < $rule["min"]) {
    $this->addError($attribute, self::RULE_MIN, $rule);
}
if ($ruleName == self::RULE_MAX && strlen($value) > $rule["max"]) {
    $this->addError($attribute, self::RULE_MAX, $rule);
}
if ($ruleName == self::RULE_MATCH && $value != $this->{$rule["match"]}) {
    $this->addError($attribute, self::RULE_MATCH, $rule);
}
#+end_src

*** Database class
Utilizza PDO per effettuare la connessione al server mariadb in esecuzione nel docker container.
Sia le credenziali di accesso al database che il domain service name (DSN) sono salvate nel file "www/.env" (vedi [[./www/.env.example][.env.example]]) e per leggerle si utilizza il package [[https://github.com/vlucas/phpdotenv][phpdotenv]].

Installazione:
#+begin_src bash
cd www
composer require vlucas/phpdotenv
#+end_src

** Migrations
Contengono i cambiamenti efftuati in ordine sul database.
/Formato migration: touch "m_$(date +%s)_name.php"/

** Models
Le classi "Model" gestiscono i dati presenti nel database e controlla che i dati seguano delle determinate regole.
Tutte le classi Model derivano dalla classe "BaseModel".

*** Registration model
Il model di registrazione si occupa della gestione dei dati di nuovi utenti e dell'interazione con il database.

Attraverso l'implementazione del metodo astratto "rules()" si possono impostare le regole che i campi della form dovranno seguire.
*Attenzione*: i nomi dei parametri, i nomi inseriti nella array resistituito da "rules()" ed i nomi dei [[./www/core/forms/Field.php][Field]] _devono_ essere uguali.

# TODO: register()

** Controllers
Le classi "Controller" svolgono il ruolo di ponte.
Esse permettono ai dati di apparire nella View richiesta dall'utente una volta prelevati dal database o di venirvi inseriti tramite una form.

*** Authentication controller
L'authentication controller ha 2 compiti fondamentali:
- registrare nuovi utenti con l'aiuto della classe "RegisterModel"
- permettere l'accesso ad utenti già registrati
# TODO
